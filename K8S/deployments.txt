deployments{upgrades+replication}(pod:ip+volume)

kubectl create deployment --image=ngnix ngnixdepl 
## The above command run, it creates deployment+replicaset. 
1. deployment.apps/nginxdepl
2. replicaset.apps/nginxdepl-<10digittoken>
3. pod/nginxdepl-<10token>-<5token>

kubectl get deployment.apps nginxdepl -o yaml | less
  apiVersion: v1
  kind: Deployment
  metadata:{name,namespace,labels}
  spec{replicas, selector.matchlabels, template:pod.spec}
  
kubectl create deployment -h ## --dry-run -o yaml

kubectl scale deployment nginxdepl --replicas=3
kubectl edit deployment nginxdepl # edit spec.replicas in yaml

kubectl get deployments --show-labels
kubectl label deployments nginxdepl state=demo ## add label

kubectl get deployment --selector state=demo ## lists nginxdepl
kubectl get all --selector app=nginxdepl ## pods,deployment,replicaset.

kubectl run nginx --image=nginx --replicas=3
kubectl get deployments --show-labels
kubectl describe pod nginx-<10token>-<5token>
kubectl label pod <> run-nginx ## removes label for a pod
kubectl get pods --show-labels

====================================Upgrades-RollingUpdate/Recreate=============================

kubectl explain deployments.spec.strategy
## Recreate is used while you want 2versions of application.
spec:
  replicas: 4
  strategy:
    type: RollingUpdate
    rollingupdate:
      maxSurge: 2       ## desirable_pods+temp_pods(4+2)
      maxUnavailable: 1 ## desirable_pods-temp_pods(4-1)

==========================================================
kubectl create -f rollout.yaml ## deployment with rollingupdate type.
kubectl rollout history <deployment(optional)>

kubectl edit deployment/<depl_name> # change image:v2
## Alternative kubectl set image=<> deployment/<>

kubectl rollout history
kubectl get all; kubectl describe deployments <depl_name> ## check what version of app is running(containers.image=v2)

# To check what version of app applied at which time.
kubectl rollout history deployment <> --revision=2
kubectl rollout history deployment <> --revision=1

kubectl rollout undo deployment <> --to-revision=1 ## gets app:v1, removes pods/replicaset created in app:v2

==========================================================
===init1.yaml

kubectl create -f init1.yaml
kubectl get pods ## status: Init:0/1
kubect expose deployment nginx --port=80 --name=myservice

==========================================================

=== StatefulSets (https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)

Statefulsets are like deployments, but provide guarantees about ordering&uniqueness of pods.
Statefulsets are valuable if application has one of following requirements.
  - unique network identifiers
  - stable persistent storage
  - ordered deployment and scaling
  - ordered automated rolling updates. 
  
limitations:
  storage must be provisioned by a PersistentVolume
  deleting statefulset will not delete storage
  headless service required to provide network identity for pods
  To terminate pods in Statefulset, scale-down to "0", delete;
  
Refer: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/
1. headless service, defined in part-1 yaml, and called in StatefulSet.spec.serviceName

==========================================================
===DaemonSets
Ref: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/

kubectl create -f daemonset-fluentd.yaml # kind:DaemonSet
kubectl get daemonset -n kube-system

===lab
kubectl create -f lab-deployment.yaml ## kind:DaemonSet kubectl get all  ## runs on all nodes. 
## if there are 3nodes in cluster, the above depl creates 3 pods on each node. 
